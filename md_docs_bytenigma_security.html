<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KauMa: BYTENIGMA Security</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">KauMa
   </div>
   <div id="projectbrief">Implementation of cryptographic algorithms for KauMa</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">BYTENIGMA Security </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this page, various possible attacks and weaknesses both on the BYTENIGMA algorithm itself and my implementation will be documented.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Key Space</h1>
<ul>
<li>A single rotor can be configured in <img class="formulaInl" alt="$256! \approx 2^{1683} $" src="form_4.png"/> different ways, giving approximately 1638 bit of security per rotor. If <img class="formulaInl" alt="$n$" src="form_3.png"/> rotors are used, the key space increases to <img class="formulaInl" alt="$n \cdot 1638$" src="form_5.png"/> bit.</li>
</ul>
<p>Note that for the last rotor in the chain, the key space is halved. Due to the complement, there always exist two rotors which cause the same mapping, since <img class="formulaInl" alt="$x \mapsto y \wedge \bar{y} \mapsto z$" src="form_6.png"/> is equivalent to <img class="formulaInl" alt="$x \mapsto \bar{y} \wedge y \mapsto z$" src="form_7.png"/>. This causes the keyspace to be reduced by a single bit.</p>
<ul>
<li>If the specific rotor wirings are considered as domain parameters and there are <img class="formulaInl" alt="$N$" src="form_8.png"/> total rotor wirings and the machine is always used with <img class="formulaInl" alt="$n$" src="form_3.png"/>, then there are simply <img class="formulaInl" alt="$N \choose n$" src="form_9.png"/> possible rotor permutations. For a chosen permutation, each rotor can be started in one of 256 positions, giving an additional <img class="formulaInl" alt="$256^n$" src="form_10.png"/> possible starting configurations. In total, this gives <img class="formulaInl" alt="$\log_2 \left({N \choose n} \cdot 256^n\right)$" src="form_11.png"/> bit of security. Assuming the use of 3 rotors ( <img class="formulaInl" alt="$n = 3$" src="form_12.png"/>), we can graph the relationship between <img class="formulaInl" alt="$N$" src="form_8.png"/> and <img class="formulaInl" alt="$\log_2 \left({N \choose n} \cdot 256^n\right)$" src="form_11.png"/>:</li>
</ul>
<p><img src="keyspace_n_3.png" alt="" class="inline" title="The expected key space when using \f$n=3\f$ and different \f$N\f$"/></p>
<p>Additionally note that the keyspace is simply limited by the number of plaintext byte encrypted. On average, a rotor at position <img class="formulaInl" alt="$n$" src="form_3.png"/> (0-indexed) rotates every <img class="formulaInl" alt="$2^n$" src="form_13.png"/> input bytes. If, during the entire encryption of a given plaintext, a rotor does not turn, it does not have to be considered as part of the keyspace. For the ciphertext, an equivalent BYTENIGMA machine can be constructed which consits only of the turned rotors, with the last rotor simply "including" the mapping applied by the rotors which did not move at all. This means that choosing more rotors is not an effective method of increasing the keyspace. For example, encrypting 512 bytes using 3 rotors is on average not less secure than using 30 rotors.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Indistinguishability &amp; Bias</h1>
<p>There is a trivial bias in the output: Any given input byte <img class="formulaInl" alt="$x$" src="form_14.png"/> can never be encrypted to itself. This can be proven as follows:</p>
<ul>
<li>When a byte <img class="formulaInl" alt="$x$" src="form_14.png"/> is passed "forward" through the rotors, it takes a "path" <img class="formulaInl" alt="$x\mapsto \cdots \mapsto y$" src="form_15.png"/> through the rotors. This "path" is then the only path in the current configuration which maps <img class="formulaInl" alt="$x$" src="form_14.png"/> to <img class="formulaInl" alt="$y$" src="form_16.png"/>.</li>
<li>At the end of the rotors, the bitwise complement of <img class="formulaInl" alt="$y$" src="form_16.png"/> is taken and passed back through the machine. By nature of a bitwise complement, is is guaranteed that <img class="formulaInl" alt="$y \neq \bar{y}$" src="form_17.png"/>.</li>
<li>The fully encrypted byte is then taken "backward" through the rotors, with a "path" <img class="formulaInl" alt="$\bar{y} \mapsto \cdots \mapsto x'$" src="form_18.png"/>.</li>
<li>Because <img class="formulaInl" alt="$y \neq \bar{y}$" src="form_17.png"/> and the paths are unique for a given rotor configuration, it is guaranteed that <img class="formulaInl" alt="$x \neq x'$" src="form_19.png"/>.</li>
</ul>
<p>This can also be experimentally verified by encrypting 131072 (1 MiB) null-bytes and printing the least common outputs:</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</div>
<div class="line"><span class="keyword">import</span> json</div>
<div class="line"><span class="keyword">import</span> base64</div>
<div class="line"> </div>
<div class="line"><span class="keyword">with</span> open(<span class="stringliteral">&quot;examples/bytenigma/2.out.json&quot;</span>) <span class="keyword">as</span> f:</div>
<div class="line">    output = base64.b64decode(json.load(f)[<span class="stringliteral">&quot;output&quot;</span>])</div>
<div class="line"> </div>
<div class="line">dist = Counter()</div>
<div class="line">dist.update({x: 0 <span class="keywordflow">for</span> x <span class="keywordflow">in</span> range(256)})</div>
<div class="line">dist.update(output)</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> key, value <span class="keywordflow">in</span> dist.most_common()[:-5:-1]:</div>
<div class="line">    print(key, value)</div>
</div><!-- fragment --><div class="fragment"><div class="line">0 0</div>
<div class="line">215 3967</div>
<div class="line">41 3967</div>
<div class="line">140 3984</div>
</div><!-- fragment --><p>This shows that the null-byte appeared exactly zero times in the output.</p>
<p>Due to this fact, indistinguishability is not given. A truly random output would have an equal distribution over all possible bytes, instead of excluding the input bytes.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Linear rotors</h1>
<p>The security of the machine strictly depends on non-linearity of the rotors. This is simply demonstrated by constructing rotors in a strictly linear fashion and encryption 1 MiB null-bytes:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    &quot;action&quot;: &quot;bytenigma&quot;,</div>
<div class="line">    &quot;rotors&quot;: [ </div>
<div class="line">        [32, 33, 34, 35, 36, 37, ..., 31],</div>
<div class="line">        [237, 238, 239, 240, 241, 242, ..., 236],</div>
<div class="line">        [150, 151, 152, 153, 154, 155, ...., 149]</div>
<div class="line">    ],</div>
<div class="line">    &quot;input&quot;: &quot;AAAA ... AAA==&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Visualising the first 512 output bytes clearly shows a linear pattern:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</div>
<div class="line"><span class="keyword">import</span> json</div>
<div class="line"><span class="keyword">import</span> base64</div>
<div class="line"> </div>
<div class="line"><span class="keyword">with</span> open(<span class="stringliteral">&quot;examples/bytenigma/all_linear_rotors.out.json&quot;</span>) <span class="keyword">as</span> f:</div>
<div class="line">    output = base64.b64decode(json.load(f)[<span class="stringliteral">&quot;output&quot;</span>])</div>
<div class="line"> </div>
<div class="line">plt.plot([x <span class="keywordflow">for</span> i, x <span class="keywordflow">in</span> enumerate(output[:512])])</div>
<div class="line">plt.grid(<span class="keyword">True</span>)</div>
<div class="line">plt.savefig(<span class="stringliteral">&quot;linear.png&quot;</span>)</div>
</div><!-- fragment --><p><img src="linear.png" alt="" class="inline" title="Value of the first 512 output bytes encrypted using linear rotors"/></p>
<h1><a class="anchor" id="autotoc_md4"></a>
Finding the position of the 0 in the first rotor</h1>
<p>Using a chosen plaintext attack, it is trivial to find the index of the <code>0</code> in the first rotor.</p>
<p>Finding the index of the <code>0</code> in the first rotor is equivalent to finding the index at which the second rotor turns. We know for a fact that this happens exactly once during the first 256 bytes encrypted using the machine.</p>
<p>We can force the output of the first rotor during the forward pass to be the same in every one of those 256 encrypted bytes, simply by sending bytes in decending order. For example, if we encrypt the byte <code>0xff</code>, lets assume <code>rotor[0][0xff]</code> is some value <img class="formulaInl" alt="$x$" src="form_14.png"/>. After the byte is encrypted, the first rotor guaranteed to be turned by one. If the next encrypted byte sent is <code>0xfe</code>, it will be mapepd to <code>rotor[0][0xfe + 1]</code> (due to the rotation by one), which is equivalent to <img class="formulaInl" alt="$x$" src="form_14.png"/>.</p>
<p>Once the output of the first rotor in the forward pass is the same, the path taken through the rest of the machine is guaranteed to be the same, as long as no other rotor turned. This means that the input to the first rotor in the backward pass is also guarnteed to be the same. Since between the two bytes <code>rotor[0]</code> was turned exactly by one, the same input <img class="formulaInl" alt="$y$" src="form_16.png"/> will be mapped to <img class="formulaInl" alt="$z$" src="form_20.png"/> and <img class="formulaInl" alt="$z - 1$" src="form_21.png"/> respectively.</p>
<p>Thus, when encrypting the sequence <code>[0xff, 0xfe, 0xfd, ..., 0]</code>, the output will be linear until the second rotor turns. If and only if the second rotor turns, linearity breaks. We can thus simply analyse the output to find this point, yielding the index of the <code>0</code> in the first rotor.</p>
<p>This can simply be demonstracted by plotting the encrypted bytes using the <code>[0xff, ..., 0]</code> sequence as input:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line"><span class="keyword">import</span> json</div>
<div class="line"><span class="keyword">import</span> base64</div>
<div class="line"> </div>
<div class="line"><span class="keyword">with</span> open(<span class="stringliteral">&quot;examples/bytenigma/backwards.out.json&quot;</span>) <span class="keyword">as</span> f:</div>
<div class="line">    output = base64.b64decode(json.load(f)[<span class="stringliteral">&quot;output&quot;</span>])</div>
<div class="line"><span class="keywordflow">for</span> i, (p, x) <span class="keywordflow">in</span> enumerate(zip(output, output[1:])):</div>
<div class="line">    <span class="keywordflow">if</span> x != (p - 1)%256:</div>
<div class="line">        print(<span class="stringliteral">&quot;linearity breaks at&quot;</span>, i)</div>
<div class="line"> </div>
<div class="line">plt.plot(list(output), <span class="stringliteral">&quot;o&quot;</span>)</div>
<div class="line">plt.grid(<span class="keyword">True</span>)</div>
<div class="line">plt.savefig(<span class="stringliteral">&quot;backwards.png&quot;</span>)</div>
</div><!-- fragment --><p><img src="backwards.png" alt="" class="inline" title="Linearity break at index 0x66 indicates that the second rotor has turned"/></p>
<p>In the plot, it is clearly evident that the linearity breaks and the script outputs that the linearity breaks at 102.</p>
<p>Indeed validation shows that <code>rotors[0][102] == 0</code>.</p>
<p>We have shown that is is possible, using a single chosen plaintext, to recover the position of the <code>0</code> in the first rotor.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Missing Nonce</h1>
<p>The BYTENIGMA encryption is equivalent to a polyalphabetic encryption, where each position in the cleartext gets assigned an alphabet based on the rotor configuration.</p>
<p>However because no nonce is used, key reuse is fatal. If an attacker has a single pair of known plaintext and corresponding ciphertext, they can deduce not only the mappings for the specific bytes from the plaintext, but also make assumptions about the alphabets if the attacker can find sequences of bytes in the ciphertext where only the first rotor has turned. This potentially allows an attacker to recover parts of an unknown ciphertext, given a single known plaintext pair. Thus, key reuse must be avoided.</p>
<p>Note: In the original enigma, this was somewhat prevented, by encrypting a "message key" at the beginning of each message using the "daily key", and encrypting the rest of the message using the "message key". However, as Rejewski's characteristic method proves, this was not fully effective.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Side Channel Attack</h1>
<p>There is an obvious side-channel attack on this specific implementation of BYTENIGMA. Let's take a look at the implementation of <code>Bytenigma::turn_rotor</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Bytenigma::Bytenigma::turn_rotor(<span class="keyword">const</span> std::size_t &amp;index) {</div>
<div class="line">  <span class="comment">// Recursively turn the rotor at `index` and all rotors to the right of it as</span></div>
<div class="line">  <span class="comment">// long as an overflow occurs</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;std::uint8_t&gt; &amp;rotor = m_rotors.at(index);</div>
<div class="line">  std::size_t old_position = m_rotor_positions.at(index);</div>
<div class="line">  m_rotor_positions.at(index) = (old_position + 1) % rotor.size();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// check if we also need to rotate the next rotor by checking</span></div>
<div class="line">  <span class="comment">// if the top-most element is currently a 0</span></div>
<div class="line">  <span class="keywordflow">if</span> (rotor.at(old_position) == 0 &amp;&amp; (index + 1) &lt; m_rotors.size()) {</div>
<div class="line">    this-&gt;turn_rotor(index + 1);</div>
<div class="line">  };</div>
<div class="line">}</div>
</div><!-- fragment --><p>Notice the recursive nature of this implementation. If and only if a rotor overflowed and there are more rotors to turn, a recursive call is made. This will incur more executed instructions than if no overflow occurred. We can thus expect that it is feasible to deduce the position of the <code>0</code> of all rotors except the last rotor in the chain by counting the number of instruction executed, or indirectly by measuring the execution time when encryption a single byte.</p>
<p>This should be fixed by making the execution time independent of an overflow, e.g. by using branchless programming. A rotor should be turned by <code>0</code> if the previous rotor did not overflow, and turned by <code>1</code> if the previous rotor overflowed. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
